# Copyright (c) 2026 Yuki Kimoto
# MIT License

class DBI {
  version "0.003";

  use DBI::Db;
  use Go::Context;
  use Native::MethodCall;
  use DBI::Constant;
  use DBI::Data;
  
  # Class Variables
  our $DRIVERS_H : cache Hash of DBI::Dr;
  
  # Class Methods
  static method connect : DBI::Db ($ctx : Go::Context, $dsn : string, $user : string = undef, $password : string = undef, $options : object[] = undef) {
    
    unless ($dsn) {
      die "DSN must be defined.";
    }
    
    # Parse DSN to find which driver to use
    my $driver_name = (string)undef;
    if (my $match = Re->m($dsn, "^dbi:([^:]+):")) {
      $driver_name = $match->cap1;
    }
    unless ($driver_name) {
      die "Invalid DSN format: '$dsn'. It must follow the 'dbi:DriverName:...' pattern.";
    }
    
    # Retrieve or load the driver manager. Initialize the driver cache if it doesn't exist.
    unless ($DRIVERS_H) {
      $DRIVERS_H = Hash->new;
    }
    my $driver = $DRIVERS_H->get($driver_name);
    
    # Load the driver class and create an instance if not cached.
    unless ($driver) {
      my $driver_class_name = "DBD::" . $driver_name . "::Dr";
      
      $driver = (DBI::Dr)Native::MethodCall->call_class_method($driver_class_name, "new");
      
      $DRIVERS_H->set($driver_name, $driver);
    }
    
    # Request the driver to create a database handle
    my $dbh = $driver->connect($ctx, $dsn, $user, $password, $options);
    
    return $dbh;
  }
  
  static method blob : DBI::Data ($value : string) {
    my $data = DBI::Data->new;
    $data->set_type_id(DBI::Data->TYPE_ID_BLOB);
    $data->set_value($value);
    return $data;
  }

  static method big_int : DBI::Data ($value : string) {
    my $data = DBI::Data->new;
    $data->set_type_id(DBI::Data->TYPE_ID_BIG_INT);
    $data->set_value($value);
    return $data;
  }

  static method big_float : DBI::Data ($value : string) {
    my $data = DBI::Data->new;
    $data->set_type_id(DBI::Data->TYPE_ID_BIG_FLOAT);
    $data->set_value($value);
    return $data;
  }
  
}
