# Copyright (c) 2026 Yuki Kimoto
# MIT License

class DBI {
  version "0.003";

  use DBI::Db;
  use Go::Context;
  use Native::MethodCall;
  use DBI::Constant;
  
  # Class Variables
  our $DRIVERS_H : cache Hash of DBI::Dr;
  
  # Class Methods
  static method connect : DBI::Db ($ctx : Go::Context, $dsn : string, $user : string = undef, $password : string = undef, $options : object[] = undef) {
    
    unless ($dsn) {
      die "DSN must be defined.";
    }
    
    # Parse DSN to find which driver to use
    my $driver_name = (string)undef;
    if (my $match = Re->m($dsn, "^dbi:([^:]+):")) {
      $driver_name = $match->cap1;
    }
    unless ($driver_name) {
      die "Invalid DSN format: '$dsn'. It must follow the 'dbi:DriverName:...' pattern.";
    }
    
    # Retrieve or load the driver manager. Initialize the driver cache if it doesn't exist.
    unless ($DRIVERS_H) {
      $DRIVERS_H = Hash->new;
    }
    my $driver = $DRIVERS_H->get($driver_name);
    
    # Load the driver class and create an instance if not cached.
    unless ($driver) {
      my $driver_class_name = "DBD::" . $driver_name;
      $driver = (DBI::Dr)Native::MethodCall->call_class_method($driver_class_name, "new");
      $DRIVERS_H->set($driver_name, $driver);
    }
      
    # Request the driver to create a database handle
    my $dbh = $driver->connect($ctx, $dsn, $user, $password, $options);
    
    return $dbh;
  }
  
}
